// Copyright 2025 The Embedded Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package isrnames

import (
	"flag"
	"fmt"
	"go/ast"
	"go/token"
	"maps"
	"os"
	"path/filepath"
	"slices"
	"strconv"
	"strings"
	"unicode"

	"github.com/embeddedgo/tools/egtool/internal/util"
	"golang.org/x/tools/go/packages"
)

const Descr = "generate IRQ handler linknames according the imported irq package"

func Main(cmd string, args []string) {
	fs := flag.NewFlagSet(cmd, flag.ExitOnError)
	fs.Usage = func() {
		fmt.Fprintf(
			os.Stderr,
			"Usage:\n  %s [OPTIONS] [OUTPUT]\nOptions:\n",
			cmd,
		)
		fs.PrintDefaults()
	}
	tags := fs.String(
		"tags", "",
		"build tags",
	)
	fs.Parse(args)
	if fs.NArg() > 1 {
		fs.Usage()
		os.Exit(1)
	}
	handlers := make(map[string]int)
	fset := token.NewFileSet()
	cfg := packages.Config{
		Mode: packages.LoadImports | packages.NeedSyntax | packages.NeedDeps,
		Fset: fset,
	}
	if *tags != "" {
		cfg.BuildFlags = []string{"-tags", *tags}
	}
	pkgs, err := packages.Load(&cfg, "")
	util.FatalErr("", err)

	// Collect the information about the handlers defined in the package.
	pkg := pkgs[0]
	for _, file := range pkg.Syntax {
		for _, d := range file.Decls {
			f, ok := d.(*ast.FuncDecl)

			if !ok || f.Doc == nil {
				continue
			}
			for _, c := range f.Doc.List {
				if !strings.HasPrefix(c.Text, "//go:") {
					continue
				}
				s := c.Text[5:]
				if i := strings.IndexFunc(s, unicode.IsSpace); i >= 0 {
					s = s[:i]
				}
				if s == "interrupthandler" {
					h := f.Name.Name
					if !strings.HasSuffix(h, "_Handler") {
						util.Fatal(
							`%s: an interrupt handler must have the "_Handler" suffix`,
							fmtPos(fset, f.Pos()),
						)
					}
					handlers[h[:len(h)-len("_Handler")]] = int(f.Pos())
					continue
				}
				if _, ok := slices.BinarySearch(directives[:], s); !ok {
					util.Fatal(
						"%s: unknown function directive: //go:%s",
						fmtPos(fset, c.Slash), s,
					)
				}
			}
		}
	}
	if len(handlers) == 0 {
		util.Fatal("package %s doesn't contain any interrupt handler", pkg.Name)
	}

	// Find the irq package in the imports and read the IRQ list from it.
	var irq *packages.Package
	for _, p := range pkg.Imports {
		if p.Name == "irq" {
			irq = p
			break
		}
	}
	if irq == nil {
		util.Fatal("package %s doesn't import any irq package", pkg.Name)
	}
	irqs := make(map[string]int)
	for _, file := range irq.Syntax {
		//fmt.Println(*file)
		for _, d := range file.Decls {
			c, ok := d.(*ast.GenDecl)
			if !ok || c.Tok != token.CONST {
				continue
			}
			for _, s := range c.Specs {
				vs, ok := s.(*ast.ValueSpec)
				if !ok {
					continue
				}
				se, ok := vs.Type.(*ast.SelectorExpr)
				if !ok {
					continue
				}
				x, ok := se.X.(*ast.Ident)
				if !ok || x.Name != "rtos" || se.Sel == nil || se.Sel.Name != "IRQ" {
					continue
				}
				//TODO: support iota ?
				if len(vs.Names) != len(vs.Values) {
					util.Fatal(
						"%s: not supported: %v",
						fmtPos(fset, vs.Pos()), vs,
					)
				}
				for i := range vs.Names {
					name, valExpr := vs.Names[i].Name, vs.Values[i]
					pos := valExpr.Pos()
					valLit, ok := valExpr.(*ast.BasicLit)
					if !ok || valLit.Kind != token.INT {
						util.Fatal(
							"%s: not supported: %v",
							fmtPos(fset, pos), valExpr,
						)
					}
					in, err := strconv.ParseInt(valLit.Value, 0, 0)
					if err != nil {
						util.FatalErr(fmtPos(fset, pos), err)
					}
					irqs[name] = int(in)
				}
			}
		}
	}

	// Match the defined handlers with the known interrupts.
	for h, pos := range handlers {
		in, ok := irqs[h]
		if !ok {
			util.Fatal("%v: unknow interrupt name: %s", token.Pos(pos), h)
		}
		handlers[h] = in
	}
	handlersT := make(map[int]string, len(handlers))
	for name, in := range handlers {
		handlersT[in] = name
	}
	out := "zisrnames.go"
	if fs.Arg(0) != "" {
		out = fs.Arg(0)
	}
	buf := make([]byte, 0, (len(handlers)+3)*60)
	ws := func(s string) { buf = append(buf, s...) }
	ws("// Code generated by egtool isrnames; DO NOT EDIT.\n\n")
	ws("package ")
	ws(pkg.Name)
	ws("\n\nimport _ \"unsafe\"\n\n")
	for _, in := range slices.Sorted(maps.Keys(handlersT)) {
		ws("//go:linkname ")
		ws(handlersT[in])
		ws("_Handler IRQ")
		buf = strconv.AppendInt(buf, int64(in), 10)
		ws("_Handler\n")
	}
	util.FatalErr("", os.WriteFile(out, buf, 0666))
}

func fmtPos(fset *token.FileSet, pos token.Pos) string {
	s := fset.Position(pos).String()
	wd, _ := os.Getwd()
	if filepath.Dir(s) == wd {
		s = filepath.Base(s)
	}
	return s
}

// Function directives, sorted for binary search.
var directives = [...]string{
	"linkname",
	"noescape",
	"noinline",
	"norace",
	"nosplit",
	"nowritebarrier",
	"nowritebarrierrec",
	"systemstack",
	"uintptrescapes",
	"uintptrkeepalive",
	"yeswritebarrierrec",
}
