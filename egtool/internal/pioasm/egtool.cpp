/*
 * Copyright (c) 2020 Raspberry Pi (Trading) Ltd.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

// Copyright 2025 The Embedded Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include "pio_assembler.h"
#include <algorithm>
#include <iostream>
#include "output_format.h"
#include "pio_disassembler.h"

struct egtool_output : public output_format {
	const char *pkgName;

	egtool_output(const char *pkgName) : output_format("egtool") {
		this->pkgName = pkgName;
	}

	std::string get_description() override {
		return "egtool format";
	}

	void output_symbols(FILE *out, bool output_labels, std::string prog, const std::vector<compiled_source::symbol> &symbols) {
		fprintf(out, "const (\n");
		for (const auto &s : symbols) {
			if (s.is_label != output_labels) {
				continue;
			}
			const char *typ = "Sym";
			if (s.is_label) {
				typ = "Lab";
			}
			if (prog != "") {
				prog += "_";
			}
			fprintf(out, "\tpio%s_%s%s = %d\n", typ, prog.c_str(), s.name.c_str(),
			        s.value);
		}
		fprintf(out, ")\n");
	}

	int output(std::string destination, std::vector<std::string> output_options, const compiled_source &source) override {
		for (const auto &program : source.programs) {
			for (const auto &p : program.lang_opts) {
				if (p.first.size() >= name.size() &&
				        p.first.compare(0, name.size(), name) == 0) {
					std::cerr << "warning: " << name << " does not support output options; " <<
					          p.first << " lang_opt ignored.\n";
				}
			}
		}
		FILE *out = open_single_output(destination);
		if (!out) {
			return 1;
		}

		fprintf(out, "// Code generated by egtool pioasm; DO NOT EDIT.\n\n");
		fprintf(out, "package %s\n\n", this->pkgName);
		fprintf(out, "import \"github.com/embeddedgo/pico/hal/pio\"\n\n");
		fprintf(out, "/// Global symbols ///\n");
		output_symbols(out, false, "", source.global_symbols);

		const char *tabs = "";

		for (const auto &program : source.programs) {
			fprintf(out, "\n/// Program %s ///\n", program.name.c_str());

			fprintf(out, "\n// Symbols\n");
			output_symbols(out, false, program.name, program.symbols);

			fprintf(out, "\n// Labels\n");
			output_symbols(out, true, program.name, program.symbols);

			fprintf(out, "\n// Code\n");

			uint32_t r32 = 0;
			r32 |= uint32_t(program.clock_div_int)<<16;
			r32 |= uint32_t(program.clock_div_frac)<<8;
			double clkDiv = double(r32 >> 8) / 256;
			uint8_t cd1 = uint8_t(r32>>8), cd2 = uint8_t(r32>>16), cd3 = uint8_t(r32>>24);

			std::string execCtrl = "";
			r32 = 0;
			if (program.sideset_opt || program.sideset_pindirs) {
				execCtrl += "sideset=";
				if (program.sideset_opt) {
					r32 |= 1<<30;
					execCtrl += "opt";
				}
				if (program.sideset_pindirs) {
					r32 |= 1 << 29;
					if (program.sideset_opt) execCtrl += "/";
					execCtrl += "pindirs";
				}
				execCtrl += " ";
			}
			r32 |= uint32_t(program.wrap & 31) << 12;
			r32 |= uint32_t(program.wrap_target & 31) << 7;
			execCtrl += "wrap=" + std::to_string(r32>>7 & 31) + "-" + std::to_string(r32>>12 & 31);
			r32 |= uint32_t(program.mov_status_type & 3) << 5;
			r32 |= uint32_t(program.mov_status_n & 31);
			switch (r32>>5 & 3) {
			case 0: execCtrl += " txlevel="; break;
			case 1: execCtrl += " rxlevel="; break;
			case 2: execCtrl += " irq="; break;
			}
			if ((r32>>5 & 3) != 3) {
				execCtrl += std::to_string(r32 & 31);
			}
			uint8_t ec0 = uint8_t(r32), ec1 = uint8_t(r32>>8), ec2 = uint8_t(r32>>16), ec3 = uint8_t(r32>>24);

			std::string shfitCtrl = "";
			r32 = 0;
			r32 |= uint32_t(program.out.threshold & 31) << 25;
			r32 |= uint32_t(program.in.threshold & 31) << 20;
			r32 |= uint32_t(program.out.right) << 19;
			r32 |= uint32_t(program.in.right) << 18;
			r32 |= uint32_t(program.out.autop) << 17;
			r32 |= uint32_t(program.in.autop) << 16;
			shfitCtrl += "out=" + std::to_string(program.out.threshold);
			if (program.out.right) {
				shfitCtrl += "/right";
			} else {
				shfitCtrl += "/left";
			}
			if (program.out.autop) {
				shfitCtrl += "/auto";
			}
			shfitCtrl += " in=" + std::to_string(program.in.threshold);
			if (program.in.right) {
				shfitCtrl += "/right";
			} else {
				shfitCtrl += "/left";
			}
			if (program.in.autop) {
				shfitCtrl += "/auto";
			}
			shfitCtrl += " fifo=";
			switch (program.fifo) {
			case fifo_config::rx:
				r32 |= 1<<31;
				shfitCtrl += "rx";
				break;
			case fifo_config::tx:
				r32 |= 1<<30;
				shfitCtrl += "tx";
				break;
			case fifo_config::txput:
				r32 |= 1<<15;
				shfitCtrl += "txput";
				break;
			case fifo_config::txget:
				r32 |= 1<<14;
				shfitCtrl += "txget";
				break;
			case fifo_config::putget:
				r32 |= 3<<14;
				shfitCtrl += "putget";
				break;
			default:
				shfitCtrl += "txrx";
			}
			uint8_t sc1 = uint8_t(r32>>8), sc2 = uint8_t(r32>>16), sc3 = uint8_t(r32>>24);

			std::string pinCtrl = "";
			r32 = 0;
			r32 |= uint32_t(program.sideset_bits_including_opt.get() & 7) << 29;
			pinCtrl += "sideset=" + std::to_string(r32>>29 & 7);
			r32 |= uint32_t(program.set_count & 7) << 26;
			if ((r32>>26 & 7) != 7) {
				pinCtrl += " set=" + std::to_string(r32>>26 & 7);
			}
			r32 |= uint32_t(program.out.pin_count & 63) << 20;
			if ((r32>>20 & 63) != 63) {
				pinCtrl += " out=" + std::to_string(r32>>20 & 63);
			}
			uint8_t pc2 = uint8_t(r32>>16), pc3 = uint8_t(r32>>24);

			fprintf(out, "const pioProg_%s pio.StringProgram = \"\" +\n", program.name.c_str());
			fprintf(out, "\t\"\\x%02x\" + //             origin:    %d\n", uint8_t(program.origin.get()), int8_t(program.origin.get()));
			fprintf(out, "\t\"\\x%02x\\x%02x\\x%02x\" + //     CLKDIV:    %g\n", cd1, cd2, cd3, clkDiv);
			fprintf(out, "\t\"\\x%02x\\x%02x\\x%02x\\x%02x\" + // EXECCTRL:  %s\n", ec0, ec1, ec2, ec3, execCtrl.c_str());
			fprintf(out, "\t\"\\x%02x\\x%02x\\x%02x\" + //     SHIFTCTRL: %s\n", sc1, sc2, sc3, shfitCtrl.c_str());
			fprintf(out, "\t\"\\x%02x\\x%02x\" + //         PINCTRL:   %s\n", pc2, pc3, pinCtrl.c_str());

			fprintf(out, "\t// Instructions:\n");

            for (int i = 0; i < (int)program.instructions.size(); i++) {
                const auto &inst = program.instructions[i];
                if (i == program.wrap_target) {
                    fprintf(out, "\t//              .wrap_target\n");
                }
                fprintf(out, "\t\"\\x%02x\\x%02x\" + // %2d:  %s\n", uint8_t(inst), uint8_t(inst>>8), i,
                        disassemble(inst, program.sideset_bits_including_opt.get(), program.sideset_opt).c_str());
                if (i == program.wrap) {
                    fprintf(out, "\t//              .wrap\n");
                }
            }
			fprintf(out, "\t\"\"\n");
		}
		if (out != stdout) {
			fclose(out);
		}
		return 0;
	}
};

extern "C" int egtoolPioasmGenerate(const char *pkgName, const char *input, const char *output) {
	pio_assembler pioasm;
	std::vector<std::string> options;
	int r = pioasm.generate(std::make_shared<egtool_output>(pkgName), input, output,
	                        options);
	return r;
}