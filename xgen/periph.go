// Copyright 2019 Michal Derkacz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"go/ast"
	"sort"
	"strconv"
	"strings"
	"text/template"
)

type instance struct {
	Name string
	Addr string
	Bus  string
}

type ctx struct {
	Constraints []string
	Pkg         string
	Periph      string
	Instances   []*instance
	Regs        []*reg
	Import      []string
	BusCode     string
}

func instances(f string, lines []string) ([]*instance, []string) {
	var insts []*instance
loop:
	for len(lines) > 0 {
		line := strings.TrimSpace(lines[0])
		switch line {
		case "Registers:", "Import:":
			break loop
		}
		lines = lines[1:]
		if line == "" {
			continue
		}
		name, line := split(line)
		addr, line := split(line)
		bus, _ := split(line)
		if _, err := strconv.ParseUint(addr, 0, 64); err != nil &&
			strings.IndexByte(addr, '.') < 0 {
			addr = "mmap." + addr
		}
		if bus == "-" {
			bus = ""
		} else if strings.IndexByte(bus, '.') < 0 {
			bus = "bus." + bus
		}
		insts = append(insts, &instance{Name: name, Addr: addr, Bus: bus})
	}
	return insts, lines
}

func uses(lines []string) ([]string, []string) {
	var imports []string
loop:
	for len(lines) > 0 {
		line := strings.TrimSpace(lines[0])
		switch line {
		case "Instances:", "Registers:":
			break loop
		}
		lines = lines[1:]
		if line == "" {
			continue
		}
		imports = append(imports, line)
	}
	return imports, lines
}

func periph(pkg, f, txt string, decls []ast.Decl, constraints []string) {
	ctx := &ctx{
		Constraints: constraints,
		Pkg:         pkg,
		Periph:      "Periph",
	}
	lines := strings.Split(txt, "\n")
	if strings.HasPrefix(lines[0], "Peripheral:") {
		ctx.Periph, _ = split(lines[0][len("Peripheral:"):])
		lines = lines[1:]
	}
	for len(lines) > 0 {
		line := strings.TrimSpace(lines[0])
		lines = lines[1:]
		switch line {
		case "Instances:":
			var insts []*instance
			insts, lines = instances(f, lines)
			ctx.Instances = append(ctx.Instances, insts...)
		case "Registers:":
			var regs []*reg
			regs, lines = registers(f, lines, decls)
			ctx.Regs = append(ctx.Regs, regs...)
		case "Import:":
			var imports []string
			imports, lines = uses(lines)
			ctx.Import = append(ctx.Import, imports...)
		}
	}
	busmap := make(map[string][]string)
	for _, inst := range ctx.Instances {
		busmap[inst.Bus] = append(busmap[inst.Bus], inst.Addr)
	}
	type busaddr struct {
		bus   string
		addrs []string
	}
	buses := make([]busaddr, 0, len(busmap))
	for bus, addrs := range busmap {
		if bus == "" {
			continue
		}
		buses = append(buses, busaddr{bus, addrs})
	}
	busmap = nil
	sort.Slice(
		buses,
		func(i, k int) bool {
			return len(buses[i].addrs) > len(buses[k].addrs)
		},
	)
	if len(buses) == 1 {
		ctx.BusCode = "return " + buses[0].bus
	} else if len(buses) > 1 {
		ctx.BusCode = "switch p.BaseAddr() {\n"
		first := true
		for _, ba := range buses {
			if first {
				ctx.BusCode += "default:"
				first = false
			} else {
				ctx.BusCode += "case " + strings.Join(ba.addrs, ",") + ":"
			}
			ctx.BusCode += "\treturn " + ba.bus + "\n"
		}
		ctx.BusCode += "}"
	}
	save(f, tmpl, ctx)
}

const tmpltext = `// DO NOT EDIT THIS FILE. GENERATED BY xgen.

{{range .Constraints -}}
	//{{.}}
{{end}}

package {{.Pkg}}

import (
	"embedded/mmio"
	"unsafe"

	{{range .Import -}}
		"{{.}}"
	{{end}}
)

{{$p := .Periph}}

type {{$p}} struct {
	{{range .Regs -}}
		{{if .Name -}}
			{{- if .SubRegs -}}
				{{.Name}} {{if .Len}}[{{.Len}}]{{end}}S{{.Type}}
			{{- else -}}
				{{.Name}} {{if .Len}}[{{.Len}}]{{end}}mmio.R{{.BitSiz}}[{{.Type}}]
			{{- end -}}
		{{- else -}}
			_ {{if .Len}}[{{.Len}}]{{end}}uint{{.BitSiz}}
		{{- end}}
	{{end}}
}

{{range .Instances -}}
	func {{.Name}}() *{{$p}} { return (*{{$p}})(unsafe.Pointer(uintptr({{.Addr}}))) }
{{end}}

func (p *{{$p}}) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

{{if .BusCode}}
	func (p *{{$p}}) Bus() bus.Bus {
		{{.BusCode}}
	}
{{end}}

{{range .Regs}}
	{{$len  := .Len}}
	{{$r   := .Name}}
	{{$sr := .SubRegs}}
	{{$bs := .BitSiz}}
	{{if .SubRegs -}}
		type S{{.Type}} struct {
		{{range .SubRegs -}}
			{{if .Name -}}
				{{.Name}} mmio.R{{$bs}}[{{.Type}}]
			{{- else -}}
				_ {{if .Len}}[{{.Len}}]{{end}}uint{{$bs}}
			{{- end}}
		{{end}}
		}
	{{end}}
	{{range .BitRegs -}}
		{{if .Name}}
			{{$br := .Name}}
			{{$rm := print "mmio.RM" $bs "[" .Type "]"}}
			{{if .NewT}}
				type {{.Type}} uint{{$bs}}
				{{if $sr}}
					{{range .Bits -}}
						{{if $len -}}
							func {{.}}_ (p *{{$p}}, i int) {{$rm}} { return {{$rm}}{ &p.{{$r}}[i].{{$br}}, {{.}}} }
						{{- else -}}
							func {{.}}_ (p *{{$p}}) {{$rm}} { return {{$rm}}{ &p.{{$r}}.{{$br}}, {{.}}} }
						{{- end}}
					{{end}}
				{{else}}
					{{range .Bits -}}
						{{if $len -}}
							func {{.}}_ (p *{{$p}}, i int) {{$rm}} { return {{$rm}}{ &p.{{$br}}[i], {{.}}} }
						{{- else -}}
							func {{.}}_ (p *{{$p}}) {{$rm}} { return {{$rm}}{ &p.{{$br}}, {{.}}} }
						{{- end}}
					{{end}}
				{{end}}
			{{end}}
		{{end}}
	{{end}}
{{end}}
`

var tmpl = template.Must(template.New("multi").Parse(tmpltext))
