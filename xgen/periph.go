// Copyright 2019 Michal Derkacz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"go/ast"
	"sort"
	"strconv"
	"strings"
)

type instance struct {
	Name string
	Addr string
	Bus  string
}

type ctx struct {
	Constraints []string
	Pkg         string
	Periph      string
	Instances   []*instance
	Regs        []*reg
	Import      []string
	BusCode     string
}

func instances(f string, lines []string) ([]*instance, []string) {
	var insts []*instance
loop:
	for len(lines) > 0 {
		line := strings.TrimSpace(lines[0])
		switch line {
		case "Registers:", "Import:":
			break loop
		}
		lines = lines[1:]
		if line == "" {
			continue
		}
		name, line := split(line)
		addr, line := split(line)
		bus, _ := split(line)
		if _, err := strconv.ParseUint(addr, 0, 64); err != nil &&
			strings.IndexByte(addr, '.') < 0 {
			addr = "mmap." + addr
		}
		if bus == "-" {
			bus = ""
		} else if strings.IndexByte(bus, '.') < 0 {
			bus = "bus." + bus
		}
		insts = append(insts, &instance{Name: name, Addr: addr, Bus: bus})
	}
	return insts, lines
}

func uses(lines []string) ([]string, []string) {
	var imports []string
loop:
	for len(lines) > 0 {
		line := strings.TrimSpace(lines[0])
		switch line {
		case "Instances:", "Registers:":
			break loop
		}
		lines = lines[1:]
		if line == "" {
			continue
		}
		imports = append(imports, line)
	}
	return imports, lines
}

func periph(pkg, f, txt string, decls []ast.Decl, constraints []string) {
	ctx := &ctx{
		Constraints: constraints,
		Pkg:         pkg,
		Periph:      "Periph",
	}
	lines := strings.Split(txt, "\n")
	if strings.HasPrefix(lines[0], "Peripheral:") {
		ctx.Periph, _ = split(lines[0][len("Peripheral:"):])
		lines = lines[1:]
	}
	for len(lines) > 0 {
		line := strings.TrimSpace(lines[0])
		lines = lines[1:]
		switch line {
		case "Instances:":
			var insts []*instance
			insts, lines = instances(f, lines)
			ctx.Instances = append(ctx.Instances, insts...)
		case "Registers:":
			var regs []*reg
			regs, lines = registers(f, lines, decls)
			ctx.Regs = append(ctx.Regs, regs...)
		case "Import:":
			var imports []string
			imports, lines = uses(lines)
			ctx.Import = append(ctx.Import, imports...)
		}
	}
	busmap := make(map[string][]string)
	for _, inst := range ctx.Instances {
		busmap[inst.Bus] = append(busmap[inst.Bus], inst.Addr)
	}
	type busaddr struct {
		bus   string
		addrs []string
	}
	buses := make([]busaddr, 0, len(busmap))
	for bus, addrs := range busmap {
		if bus == "" {
			continue
		}
		buses = append(buses, busaddr{bus, addrs})
	}
	busmap = nil
	sort.Slice(
		buses,
		func(i, k int) bool {
			return len(buses[i].addrs) > len(buses[k].addrs)
		},
	)
	if len(buses) == 1 {
		ctx.BusCode = "return " + buses[0].bus
	} else if len(buses) > 1 {
		ctx.BusCode = "switch p.BaseAddr() {\n"
		first := true
		for _, ba := range buses {
			if first {
				ctx.BusCode += "default:"
				first = false
			} else {
				ctx.BusCode += "case " + strings.Join(ba.addrs, ",") + ":"
			}
			ctx.BusCode += "\treturn " + ba.bus + "\n"
		}
		ctx.BusCode += "}"
	}
	save(f, tmpl, ctx)
}

const tmplR = `// Code generated by xgen -g; DO NOT EDIT.

{{range .Constraints -}}
	//{{.}}
{{end}}

package {{.Pkg}}

import (
	"embedded/mmio"
	"unsafe"

	{{range .Import -}}
		"{{.}}"
	{{end}}
)

{{$p := .Periph}}

type {{$p}} struct {
	{{range .Regs -}}
		{{if .Name -}}
			{{- if .SubRegs -}}
				{{.Name}} {{if .Len}}[{{.Len}}]{{end}}S{{.Type}}
			{{- else -}}
				{{.Name}} {{if .Len}}[{{.Len}}]{{end}}mmio.R{{.BitSiz}}[{{.Type}}]
			{{- end -}}
		{{- else -}}
			_ {{if .Len}}[{{.Len}}]{{end}}uint{{.BitSiz}}
		{{- end}}
	{{end}}
}

{{range .Instances -}}
	func {{.Name}}() *{{$p}} { return (*{{$p}})(unsafe.Pointer(uintptr({{.Addr}}))) }
{{end}}

func (p *{{$p}}) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

{{if .BusCode}}
	func (p *{{$p}}) Bus() bus.Bus {
		{{.BusCode}}
	}
{{end}}

{{range .Regs}}
	{{$len  := .Len}}
	{{$r   := .Name}}
	{{$sr := .SubRegs}}
	{{$bs := .BitSiz}}
	{{if .SubRegs -}}
		type S{{.Type}} struct {
		{{range .SubRegs -}}
			{{if .Name -}}
				{{.Name}} mmio.R{{$bs}}[{{.Type}}]
			{{- else -}}
				_ {{if .Len}}[{{.Len}}]{{end}}uint{{$bs}}
			{{- end}}
		{{end}}
		}
	{{end}}
	{{range .BitRegs -}}
		{{if .Name}}
			{{$br := .Name}}
			{{$rm := print "mmio.RM" $bs "[" .Type "]"}}
			{{if .NewT}}
				type {{.Type}} uint{{$bs}}
				{{if $sr}}
					{{range .Bits -}}
						{{if $len -}}
							func {{.}}_ (p *{{$p}}, i int) {{$rm}} { return {{$rm}}{ R: &p.{{$r}}[i].{{$br}}, Mask: {{.}}} }
						{{- else -}}
							func {{.}}_ (p *{{$p}}) {{$rm}} { return {{$rm}}{ R: &p.{{$r}}.{{$br}}, Mask: {{.}}} }
						{{- end}}
					{{end}}
				{{else}}
					{{range .Bits -}}
						{{if $len -}}
							func {{.}}_ (p *{{$p}}, i int) {{$rm}} { return {{$rm}}{ R: &p.{{$br}}[i], Mask: {{.}}} }
						{{- else -}}
							func {{.}}_ (p *{{$p}}) {{$rm}} { return {{$rm}}{ R: &p.{{$br}}, Mask: {{.}}} }
						{{- end}}
					{{end}}
				{{end}}
			{{end}}
		{{end}}
	{{end}}
{{end}}
`

const tmplU = `// Code generated by xgen; DO NOT EDIT.

{{range .Constraints -}}
	//{{.}}
{{end}}

package {{.Pkg}}

import (
	"embedded/mmio"
	"unsafe"

	{{range .Import -}}
		"{{.}}"
	{{end}}
)

{{$p := .Periph}}

type {{$p}} struct {
	{{range .Regs -}}
		{{if .Name -}}
			{{.Name}} {{if .Len}}[{{.Len}}]{{end}}R{{.Type}}
		{{- else -}}
			_ {{if .Len}}[{{.Len}}]{{end}}uint{{.BitSiz}}
		{{- end}}
	{{end}}
}

{{range .Instances -}}
	func {{.Name}}() *{{$p}} { return (*{{$p}})(unsafe.Pointer(uintptr({{.Addr}}))) }
{{end}}

func (p *{{$p}}) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

{{if .BusCode}}
	func (p *{{$p}}) Bus() bus.Bus {
		{{.BusCode}}
	}
{{end}}

{{range .Regs}}
	{{$len  := .Len}}
	{{$subr := .SubRegs}}
	{{$rr   := .Name}}

	{{if $subr -}}
		type R{{$rr}} struct {
		{{range $subr -}}
			{{if .Name -}}
				{{.Name}} R{{.Type}}
			{{- else -}}
				_ {{if .Len}}[{{.Len}}]{{end}}uint{{.BitSiz}}
			{{- end}}
		{{end}}
	}
	{{end}}

	{{range .BitRegs}}
		{{if .Name}}
			{{$r    := .Name}}
			{{$uint := print "uint" .BitSiz}}
			{{$u    := print "U" .BitSiz}}
			{{$mu   := print "mmio." $u}}
			{{$ru   := print "r." $u}}
			{{$um   := print "UM" .BitSiz }}
			{{$mum  := print "mmio." $um}}
			{{$rmum := print "rm." $um}}
			{{$po   := print "unsafe.Pointer(uintptr(unsafe.Pointer(p))+" .Offset ")"}}
			{{$bits := .Type }}
			{{$reg  := print "R" .Type }}
			{{$rm   := print "RM" .Type }}

			{{if .NewT }}
				type {{$bits}} {{$uint}}

				type {{$reg}} struct { {{$mu}} }

				func (r *{{$reg}}) LoadBits(mask {{$bits}}) {{$bits}} { return {{$bits}}({{$ru}}.LoadBits({{$uint}}(mask))) }
				func (r *{{$reg}}) StoreBits(mask, b {{$bits}})       { {{$ru}}.StoreBits({{$uint}}(mask), {{$uint}}(b)) }
				func (r *{{$reg}}) SetBits(mask {{$bits}})            { {{$ru}}.SetBits({{$uint}}(mask)) }
				func (r *{{$reg}}) ClearBits(mask {{$bits}})          { {{$ru}}.ClearBits({{$uint}}(mask)) }
				func (r *{{$reg}}) Load() {{$bits}}                   { return {{$bits}}({{$ru}}.Load()) }
				func (r *{{$reg}}) Store(b {{$bits}})                 { {{$ru}}.Store({{$uint}}(b)) }

				type {{$rm}} struct { {{$mum}} }

				func (rm {{$rm}}) Load() {{$bits}}   { return {{$bits}}({{$rmum}}.Load()) }
				func (rm {{$rm}}) Store(b {{$bits}}) { {{$rmum}}.Store({{$uint}}(b)) }

				{{if $subr}}
					{{range .Bits}}
						{{if $len}}
							func {{.}}_ (p *{{$p}}, n int) {{$rm}} {
								return {{print $rm "{" $mum "{R: &p." $rr "[n]." $r "." $u ", Mask:" $uint "(" . ")}}"}}
							}
						{{else}}
							func {{.}}_ (p *{{$p}}) {{$rm}} {
								return {{print $rm "{" $mum "{R: &p." $rr "." $r "." $u ", Mask:" $uint "(" . ")}}"}}
							}
						{{end}}
					{{end}}
				{{else}}
					{{range .Bits}}
						{{if $len}}
							func {{.}}_ (p *{{$p}}, n int) {{$rm}} {
								return {{print $rm "{" $mum "{R: &p." $r "[n]." $u ", Mask:" $uint "(" . ")}}"}}
							}
						{{else}}
							func {{.}}_ (p *{{$p}}) {{$rm}} {
								return {{print $rm "{" $mum "{R: &p." $r "." $u ", Mask:" $uint "(" . ")}}"}}
							}
						{{end}}
					{{end}}
				{{end}}
			{{end}}
		{{end}}
	{{end}}
{{end}}
`
